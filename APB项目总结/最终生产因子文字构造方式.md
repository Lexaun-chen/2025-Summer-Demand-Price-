## 卖方分歧度因子构建      

#### 数据准备与说明
- 数据源：使用逐笔委托数据，路径格式为：```/data/cephfs/order/YYYYMMDD.parquet```           
- 回测时间： 2016-06-20 到 2025-06-30        
- 交易日列表为```trading_dates = pd.date_range(start=start_date, end=end_date, freq='D')``` 跳过无原始委托数据的日期                      
- 使用DuckDB进行内存数据处理，用函数1计算某交易日因子，输出日度dataframe；函数2处理单个交易日，保存函数1输出的dataframe，识别并跳过已生成因子或不存在原始委托文件的日期，输出 “日期  bool  状态（已存在or成功算True，不存在原文件或遇到错误算False）”；函数3创建进程池，进行并行计算，输出最终的因子储存目录       
- 负向因子，需要加负号（我统一是最后直接对滚动平湖后的因子取负）    


#### 因子说明

因为前后尝试过不同的买卖方向、切割时间段以及缩尾力度，我原本按以下逻辑处理这三个维度的信息：首先为不同时间段设置sql_query的筛选条件列表，针对每一个时间段分别获取买卖双方基础临时表，计算价格分位数临时表，进行价格缩微得到缩尾表。

      买卖方向: ask 或 bid 
       
      时间段维度：（前闭后开）
           开盘前1：9:15-9:20（pre_open_915_920）
           开盘前2：9:20-9:25（pre_open_920_925）
           早盘：9:30-10:00（early_930_1000）
           主交易时段：10:00-14:30（main_1000_1430）
           尾盘1：14:30-14:57（late_1430_1457）
           尾盘2：14:57-15:00（close_1457_1500）
           连续交易时段：9:30-14:57（continue_930_1457）

      处理方式：p01_p99  p03_p97 

      示例最终因子列名：  ask_main_1000_1430_p03_p97

      理论上最后得到的大表有 2*7*2 列  

最后只需要用到 ```卖方``` ```3%-97%分位数缩尾处理```  ```主交易时段：10:00-14:30（main_1000_1430） 以及  尾盘2：14:57-15:00（close_1457_1500）``` 这个维度下面的2个因子。          
这里我保留了对时间段维度的完整划分，在实际计算时，为了节约时间，可以直接不定义其他时间段的查询。    


#### 因子计算流程
1. 对定义的每个时间段，筛选卖方订单：``` order_type = 'A'``` ``` order_details = 'L'``` ```order_side = -1```    
2. 保留证券代码、order_price, order_volume指标，建立临时表    
3. 异常值缩尾处理： 对每个证券该时段卖方订单价格进行缩尾处理，得到新的临时表    
        
        计算每个证券订单价格的3%和97%分位数
        将低于3%分位数的价格替换为3%分位数值
        将高于97%分位数的价格替换为97%分位数值

4. 在缩尾后的临时表上，，按证券代码分组计算价格分歧度

        4.1 计算该时段各证券加权平均对数价格
                 
                 计算每个订单的订单价格的自然对数值
                 计算 对数价格×订单量
                 将所有订单的"对数价格×订单量"相加，再除以它在该时段的总订单量，得到其加权平均对数价格

        4.2 计算该时段各证券每个订单价格与其加权对数价格的偏离程度：

                  对每个订单，计算其对数价格与加权平均对数价格的差值
                  将差值平方，计算 平方差×订单量
                  将该证券所有订单的"平方差×订单量"相加，再除以它在该时段的总订单量
                  对结果开根号，得到订单量加权的价格标准差，即价格分歧度

5. 根据前序定义的因子类型，把每日因子保存为 [date, security_code, factor1， factor2， ···]格式的parquet文件

#### 对因子进行20天滚动平滑
1. 用```os.path.join```得到输出路径下的所有日度因子parquet文件的pattern
2. 用duckdb读取为一个大表，根据前序定义的因子类型格式为 [date, security_code, factor1， factor2， ···]
2. 对传入的factor——list中的每一列，将security_code作为列，date作为索引，该列因子值为value创建透视表
3. 对透视表rolling取mean（），rolling参数为 window=20， min_window=5，
4. 将计算结果从宽格式转回长格式（日期、证券代码、因子值）
5. 对因子值取负并保存


#### 因子合成
1. 获取 10：00-14：30 与 14：30-14：57 两个时间段的20d滚动平滑后的卖方分歧度因子
2. 对两因子分别进行zscore标准化
3. 将标准化后的因子等权相加等全相加







## APB 因子构建

#### 数据准备与说明
- 数据源：使用逐笔委托数据，路径格式为：```/data/cephfs/order/YYYYMMDD.parquet```； 复权因子表:```jydb.DZ_AdjustingFactor```；```smartquant.ReturnDaily```              
- 回测时间： 2016-06-20 到 2025-06-30   
- 订单时间在连续交易时段内(9:30:00-14:57:00)，即时间戳介于93000000和145700000之间     
- 对订单价格统一进行1%-99%分位数缩尾处理，最后一步取LN时注意极值处理
- 交易日列表为```trading_dates = pd.date_range(start=start_date, end=end_date, freq='D')``` 跳过无原始委托数据的日期                      
- 使用DuckDB进行内存数据处理，用函数1计算某交易日因子，输出日度dataframe；函数2处理单个交易日，保存函数1输出的dataframe，识别并跳过已生成因子或不存在原始委托文件的日期，输出 “日期  bool  状态（已存在or成功算True，不存在原文件或遇到错误算False）”；函数3创建进程池，进行并行计算，输出最终的因子储存目录   
- 正向因子，不需要取负    


### 日频买方委托订单APB因子

##### 因子计算流程
1. 筛选买方订单：``` order_type = 'A'``` ``` order_details = 'L'``` ```order_side = 1``` ```order_time >= 93000000``` ```order_time <= 145700000```
2. 保留security_code、order_price, order_volume指标，建立临时表    
3. 异常值缩尾处理： 对临时表中每个证券订单价格进行缩尾处理，得到新的临时表    
        
        计算每个证券订单价格的1%和99%分位数
        将低于1%分位数的价格替换为1%分位数值
        将高于99%分位数的价格替换为99%分位数值

4. 在缩尾后的临时表上，按证券代码分组计算两种价格均值，储存在新的表中

        4.1 计算各证券所有订单加权平均价格(TWAP)
                 
                 简单计算该证券所有订单价格的算术平均值
                 TWAP = AVG(order_price)

        4.2 计算各证券的委托量加权平均价格(VWAP)：

                  按订单量加权计算证券所有订单价格的平均值
                  VWAP = SUM(order_price * order_volume) / SUM(order_volume)

5. 计算APB因子：在新表上，按证券代码分组，计算TWAP与VWAP的比值的自然对数
        
                  APB = ln(TWAP / VWAP)
                  异常值处理：如果TWAP或VWAP为零或负值，则APB为空值(NULL)

5. 把保存为 [date, security_code, daily_APB_p01_p99]格式的parquet文件

##### 对因子进行20天滚动平滑
1. 用```os.path.join```得到输出路径下的所有日度因子parquet文件的pattern
2. 用duckdb读取为一个大表，根据前序定义的因子类型格式为 [date, security_code, daily_APB_p01_p99]
2. 将security_code作为列，date作为索引，该daily_APB_p01_p99为value创建透视表
3. 对透视表rolling取mean（），rolling参数为 window=20， min_window=5，
4. 将计算结果从宽格式转回长格式（日期、证券代码、因子值）




### 5天跨日复权版买方委托订单APB因子

##### 日度数据处理

1. 筛选买方订单：``` order_type = 'A'``` ``` order_details = 'L'``` ```order_side = 1``` ```order_time >= 93000000``` ```order_time <= 145700000```
2. 保留security_code、order_price, order_volume指标，添加交易日date字段，建立临时表   
3. 异常值缩尾处理： 对临时表中每个证券订单价格进行缩尾处理，得到新的临时表    
        
        计算每个证券订单价格的1%和99%分位数
        将低于1%分位数的价格替换为1%分位数值
        将高于99%分位数的价格替换为99%分位数值 
4. 日度统计量计算：  对缩尾处理后的数据，计算每只证券每个交易日的以下统计量

        订单价值总和（daily_value_p01_p99）：每个订单的价格与数量的乘积之和，用于后续计算VWAP
        价格总和（daily_sum_price_p01_p99）：所有订单价格的简单加总，用于后续计算TWAP
        订单数量总和（daily_volume_p01_p99）：所有订单数量的总和
        订单笔数（daily_count_p01_p99）：订单的总笔数

5. 得到每天每只股票的汇总数据，储存为日度parquet文件


##### 价格复权处理

1. 复权数据准备：提前保存每个交易日对应的复权因子数据，确保复权因子（AdjustingFactor）和除权除息日期（ExDiviDate）字段可用。

2. 对价格相关统计量复权：只对价格相关字段进行复权，交易量相关字段保持不变

         创建需要复权的字段副本：
               adj_value_p01_p99：对应daily_value_p01_p99的复权版本
               adj_price_p01_p99：对应daily_sum_price_p01_p99的复权版本
        
        复权处理步骤：
               按照除权除息日期从新到旧排序复权因子数据
               对于每个除权除息日期，找出该日期之后（含该日期）且尚未复权的数据
               将这些数据的价格相关字段乘以对应的复权因子
               标记这些数据为已复权状态
               复权后的数据保留原始数据的所有字段，并增加复权后的价格字段。

5. 处理前一步得到的所有日度汇总parquet数据

##### 5日滚动窗口因子计算

1. 滚动窗口数据准备
滚动窗口的数据准备采用两层函数结构，分别是整体调度函数calculate_rolling_average()和单日处理函数process_single_date()。

        整体调度函数calculate_rolling_average()：

               通过glob.glob()函数获取数据目录下所有日度统计数据的Parquet文件列表
               从文件名中提取日期信息（假设文件名格式为"YYYYMMDD.parquet"）
               将日期和对应的文件路径组成元组对，并按日期升序排序，形成file_dates列表
               如果指定了日期范围（start_date和end_date），则筛选出该范围内的文件
               确定需要处理的日期索引列表，从第window_size-1个文件开始（确保每个处理日有足够的历史数据）
               使用多进程并行处理每个日期的数据计算

        单日处理函数process_single_date()：

               接收当前日期索引i、文件日期列表file_dates和窗口大小window_size等参数
               获取当前日期和对应的文件路径
               检查输出文件是否已存在，若存在则跳过处理
               确定滚动窗口的起始索引：start_idx = max(0, i-window_size+1)，确保不会索引到负数
               获取窗口内所有日期的文件路径列表：recent_files = [path for _, path in file_dates[start_idx:i+1]]
               读取这些文件的数据并合并成一个DataFrame
               按证券代码和日期对合并后的数据进行排序，为后续计算做准备

2. 滚动窗口统计量计算

对于每个处理日期，单日处理函数继续执行以下步骤：

        对于该日期对应5日窗口内所有的数据，按证券代码分组计算两种复权平均价格，存为新表

               复权后的委托量加权平均价格（adj_vwap_p01_p99）：窗口内adj_value_p01_p99之和除以窗口内daily_volume_p01_p99之和
               复权后的简单平均价格（adj_twap_p01_p99）：窗口内adj_price_p01_p99之和除以窗口内daily_count_p01_p99之和


3. APB因子计算：在新表上，按证券代码分组，计算Adj_TWAP与Adj_VWAP的比值的自然对数

      5d_apb_p01_p99 = ln(adj_twap_p01_p99 / adj_vwap_p01_p99)
      异常值处理：将计算结果中的正无穷大和负无穷大值替换为NaN

4. 最终因子只保留[date, security_code, 5d_apb_p01_p99]三列，保存输出日度因子parquet文件


##### 对因子进行20天滚动平滑
1. 用```os.path.join```得到输出路径下的所有日度因子parquet文件的pattern
2. 用duckdb读取为一个大表，根据前序定义的因子类型格式为 [date, security_code, 5d_apb_p01_p99]
2. 将security_code作为列，date作为索引，该daily_APB_p01_p99为value创建透视表
3. 对透视表rolling取mean（），rolling参数为 window=20， min_window=5，
4. 将计算结果从宽格式转回长格式（日期、证券代码、因子值）




### 因子合成
1. 获取 日频 与 5天跨日复权 两个版本的20d滚动平滑后的买方委托订单APB因子
2. 对两因子分别进行zscore标准化
3. 将标准化后的因子等权相加等全相加
